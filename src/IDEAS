
  == Description ==

    Most manager classes holds lists of different handler/observer classes
    and other tracked informations on a "per-manager" basis, resulting in a
    bunch of (mainly empty) lists.

    Tracking is done in a way that handlers are tracked by their respective
    managers and managers are tracked by their client. By moving the parsing code
    in the specific handlers and tracking the requests directly with the client,
    it would be possible to by-pass the manager step and avoid this indirection
    (which basically does the same the client does (tracking and untracking)).

    A UserHandler class would contain a static map for all information tracking.
    Real handlers would derive from it and use this map for all info tracking.

  == Advantages ==

    - Using IqHandler as a base class for UserHandler allows to use clientbase's
      tracking directly and get rid of all local tracking code and per-manager
      handler maps (which is faster and smaller and would allow the parsing to be
      somewhat more local).

    - Smaller binary and memory footprint.

  == Disadvantages ==

    - We loose track of the manager and associated client, so we need to make
      sure that no handler needs any info from them. Ie What happens if we need
      to send a response to a result (eg an error) ?

  == Example ==

    void request( ... )
    {
      if( !m_parent )
        return;
      const std::string& id = m_parent->getID();
      IQ* iq = new IQ( iqType, id, parent, ... );

      // generic track map for all infos
      if( needsInfoTracking )
        handler::trackInfos( id, TrackItem( track1, track2 ) );

      // no more local tracking because we track a handler, not a manager
      m_parent->trackID( handler, id, context );
      m_parent->send( iq );
    }

    /* Base class for all user handlers. */
    class UserHandler : public IqHandler
    {
      virtual bool handleIqID() = 0;
      static std::map< std::string, StringPair > m_infoTrackMap;
      static void trackInfos( id, item ) { m_infoTrackMap[id] = item; }
    }

    /* An actual handler. It can retrieve info using m_infoTrackMap. */
    class NodeHandler : public UserHandler
    {
      public:
        virtual void handleNodeCreation( service, node ) = 0;
        virtual void handleItemCreation( service, node, item ) = 0;
      private:
        bool handleIqID( IQ* iq, int context )
        {
          // parse response request
          // ...
          handleNodeCreation( service, node );
          // ...
          handleItemCreation( service, node, item );
        }
    }

