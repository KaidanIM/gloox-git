\section{Technical Approach}

\subsection{Architecture}

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.0}
\end{center}
\caption{Project Architecture}
\label{fig:architecture}
\end{figure}

\paragraph{}
Figure \ref{fig:architecture} shows the project's architecture. On one hand side, a Feeder is responsible for creating or gathering data that has to be processed. This data is sent to one of the waiting Workers at a time via the XMPP server. The Workers, on the other hand side, do the necessary processing and return the result to the Feeder. This result is stored in a database. The Statistics Viewer can be used to view statistics about the returned results and the grid operation.

\paragraph{}
Feeder and Worker are each split in two main components. This is shown in Figures \ref{fig:feeder} and \ref{fig:worker}, respectively.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.9}
\end{center}
\caption{The Feeder in Detail}
\label{fig:feeder}
\end{figure}

\paragraph{}
The Feeder Library communicates with the XMPP Server and the Worker on behalf of the Data Gatherer. Likewise does the Worker Library take care of the XMPP communication for the Algorithm Implementation. Data Gatherer as well as Algorithm Implementation know nothing about the wherefrom and whereabout of the data, respectively.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.10}
\end{center}
\caption{The Worker in Detail}
\label{fig:worker}
\end{figure}

\paragraph{}
From the previous figures it is clear that both Worker and Feeder are likely to contain similar code which could be shared. Since the connectivity functionality is identical for both of the higher level components and is self-contained, it was decided to write a generic XMPP client library that can even be (and by the time of this writing is) used in other projects. Figure \ref{fig:justification} shows the collaboration of Feeder Library, Worker Library and XMPP Client Library.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.8}
\end{center}
\caption{Usage of the XMPP Client Library}
\label{fig:justification}
\end{figure}

\paragraph{}
Both higher level libraries base their entire network-based communication on the XMPP Client Library. Receiving and sending data is completely transparent. The XMPP Client Library could be replaced by another library implementing any other means of communication without hassle.

\subsection{Addressing of Workers}
\paragraph{}
The Feeder needs to be able to distinguish between different Workers in order to keep track of them and sending work data to a specific one. It does so by keeping a map of addresses of connected Workers and their respective current status.

\subsubsection{Node Addressing in XMPP}
\paragraph{}
In general, an address in XMPP (also known as Jabber ID or JID) is built using the following syntax:
\begin{center}
\texttt{[\{local\}@]\{server\}[/\{resource\}]}
\end{center}
An addressable node can be either of the following:
\begin{description}
\item[client] with an address of the form: \texttt{\{local\}@\{server\}/\{resource\}}
\item[component] with an address of the form: \texttt{\{local\}@\{server\}} 
\item[server] with  an address of the form: \texttt{\{server\}}
\end{description}
\paragraph{}
For addressing, the resource part is optional under certain circumstances and an entity is always reachable by addressing the bare (without resource part) Jabber ID. Even though an XMPP address looks a lot like an ordinary email address, the XMPP specification allows for more characters to be used in the local part, even whitespace is valid. The server part depends on domain naming rules valid in the Internet. This addressing scheme, including the range of valid characters in an XMPP address, is decribed in greater detail in RFC 3920: XMPP Core \cite{xmpp-core}.

\subsubsection{Addressing in XMPPGrid}
\label{sec:addressing}
\paragraph{}
The design of Worker and Feeder Libraries does not impose any limit whatsoever on the addresses of Workers besides those already defined in RFC 3920. This means it is even possible to have a Worker use the same Jabber ID like a users Instant Messaging account, except for the resource part. An example: User Joe has got an account on server \texttt{example.org}. Their client adds a resource of \texttt{JoesChatClient}. The resulting JID, under which Joe is reachable for chatting, would be:
\begin{center}
\texttt{joe@example.org/JoesChatClient}
\end{center}
If Joe chose to have a Worker use the same address, the full JID would look like:
\begin{center}
\texttt{joe@example.org/JoesWorker}
\end{center}
Following this scheme, it is possible to run a whole grid using only a single account. Each Worker would simply add a different resource part to the bare address to form its unique JID.
\paragraph{}
Further advantages of using XMPP are discussed in Section \ref{sec:extensibility}.

\subsection{The XMPP Client Library}
\label{sec:clientlib}
\paragraph{}
The XMPP Client Library consists of one main class and several helper classes. The main class, \texttt{JClient}, is derived from the stream handling class \texttt{Stream}, which in turn is derived from the XML parser interface \texttt{Parser} and an XML tree abstraction, \texttt{Tree}. The inheritance diagram for \texttt{JClient} is shown in Figure \ref{fig:inhjclient}.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.11}
\end{center}
\caption{Inheritance Diagram for Class \texttt{JClient}}
\label{fig:inhjclient}
\end{figure}

\paragraph{}
The classes \texttt{Tree}, \texttt{Parser} and \texttt{Stream} were taken from the Iksemelmm\footnote{Originally written by Igor Goryachieff \texttt{<igor@jahber.org>}} library and modified slightly. They live in the \texttt{Iksemel} namespace and form an object-oriented wrapper interface to the Iksemel library. The build system creates a so-called convenience library from them which is linked into the final XMPP Client Library.

\paragraph{}
The most simple example of using the XMPP Client Library would look like shown in Figure \ref{fig:usageExample}.

\begin{figure}[H]
\begin{listing}{1}
void Class::doIt()
{
  JClient* j = new JClient( "user", "password",
                            "server", "resource" );
  j->connect();
}
\end{listing}
\caption{Simple XMPP Client Library Usage Example}
\label{fig:usageExample}
\end{figure}

\paragraph{}
In this fictitious function \texttt{Class::doIt()} a new \texttt{JClient} object is created and initialised with the account's credentials necessary for connecting and authenticating to an XMPP server (lines 3 and 4). As a consequence, the constructor of \texttt{JClient} as shown in Figure \ref{fig:JClientConstructor} is called.

\begin{figure}[H]
\begin{listing}{1}
JClient::JClient( const std::string& username,
                  const std::string& password,
                  const std::string& server,
                  const std::string& resource, int port )
  : m_username( username ), m_password( password ),
  m_server( server ), m_resource( resource ),
  m_port( port ), m_thread( 0 ),
  m_tls( true ), m_sasl( true ),
  m_autoPresence( false ), m_manageRoster( true ),
  m_handleDisco( true ), m_idCount( 0 ), m_roster( 0 ),
  m_disco( 0 )
{
  init();
}
\end{listing}
\caption{Constructor of class JClient (simplified)}
\label{fig:JClientConstructor}
\end{figure}

\paragraph{}
Basically, a number of member variables are initialised (lines 5 to 11). Most importantly, Transport Layer Security\footnote{Encryption of the communication channel.} (TLS) \cite{rfc2246} and Simple Authentication and Security Layer\footnote{Secure Authentication even without encrypted communication channel.} (SASL) \cite{rfc2222} are enabled (line 8). Additionally, but not shown in Figure \ref{fig:JClientConstructor}, some more XMPP features which the library supports, are enabled by the \texttt{init()} function (line 13). This includes, for example, Service Discovery and Roster Management.

\paragraph{}
The function \texttt{connect()}, called in line 5 in Figure \ref{fig:usageExample}, establishes the connection to the XMPP server and creates a new thread that receives incoming TCP/IP packets and hands them to the XML parser of Iksemel.

\paragraph{}
The following interaction with the XMPP server is completely event driven. This is why the example in Figure \ref{fig:usageExample} is not very useful as it is: An application using the Library like this will never now that anything happened to the XMPP connection. The solution is to use the event notification interfaces the Library offers.

\subsection{Event Notification Interfaces}
\label{sec:interfaces}
\paragraph{}
The client library offers a simple yet powerful public interface that enables programs to receive events from an XMPP server with approximately less than 10 additional lines of code. The supported events are:
\begin{itemize}
\item Established and canceled (also lost) connection
\item Incoming messages
\item Incoming Info/Query (IQ) stanzas
\item Incoming presence stanzas
\item Incoming subscription stanzas
\end{itemize}
\paragraph{}
With it, all the possible stanza types that XMPP Core supports are covered. A namespace filter can be utilised for IQ events. In addition to these, the library offers the following interfaces which in turn make heavy use of the previously named ones:
\begin{itemize}
\item Roster Management
\item Service Discovery
\end{itemize}
\paragraph{}
Both of these are built on IQ stanzas and use the namespace filtering mechanism mentioned above.


\paragraph{}
The event notification scheme used by the Client Library follows the so-called Observer Pattern \cite{wikipedia003}. An object interested in XMPP events needs to indicate this to the client library by registering with it as an appropriate event handler. When a stanza arrives from the server, the library calls a special function in every registered object. Figure \ref{fig:observer1} shows an example sequence of registering with the Client Library and being called back by it later on.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.7}
\end{center}
\caption{Sequence Diagram Illustrating the Observer Pattern}
\label{fig:observer1}
\end{figure}
\paragraph{}
The following interfaces are available for use by an object. Each interface is defined in their own header file for inclusion by interested classes. The virtual function definded therein and listed here have to be reimplemented by the listener objects in order to actually receive the occuring events they intend to listen for.

\paragraph{ConnectionListener}
To be notified about connection-related events, an object must be derived from \texttt{ConnectionListener}. It has to be added to the listener queue by calling
\begin{flushleft}
\texttt{JClient::registerConnectionListener( ConnectionListener* cl );}
\end{flushleft}
After establishing an connection to the XMPP server and successfully authenticating with it, the function
\begin{flushleft}
\texttt{virtual void onConnect() \{\};}
\end{flushleft}
is called in any registered object. Likewise, as soon as a disconnect is detected, either due to a closed stream or a lost TCP/IP connection, 
\begin{flushleft}
\texttt{virtual void onDisconnect() \{\};}
\end{flushleft}
is called.

\paragraph{MessageHandler}
In XMPP, Messages contain the text of a conversation between client users, usually humans. By registering a \texttt{MessageHandler}-derived object with the Library, a program will receive such incoming messages for further processing. Registration happens by calling
\begin{flushleft}
\texttt{void registerMessageHandler( MessageHandler* mh );}
\end{flushleft}
Upon an incoming Message stanza, \texttt{handleMessage()} is called, which has the following signature:
\begin{flushleft}
\texttt{virtual void handleMessage( iksid* from, iksubtype type, const char *msg ) \{\};}
\end{flushleft}
The processing object has immediate knowledge of sender (\texttt{iksid* from}), type (\texttt{iksubtype type}) and content (\texttt{const char *msg}) of the incoming message.

\paragraph{IqHandler}
IQ stanzas usually contain control commands that are evaluated by the client software of an entity and not shown to the user. By registering an \texttt{IqHandler}-derived object with the Library, a program will receive such incoming IQ stanzas for further processing. Registration happens by calling
\begin{flushleft}
\texttt{void registerIqHandler( IqHandler* ih, std::string xmlns );}
\end{flushleft}
Upon an incoming IQ stanza, \texttt{handleIq()} is called, which has the following signature:
\begin{flushleft}
\texttt{virtual void handleIq( const char* xmlns, ikspak* pak ) \{\};}
\end{flushleft}
The processing object has immediate knowledge of the XML namespace (\texttt{const char* xmlns}) and, additionally, access to the complete packet's content by accessing \texttt{ikspak* pak}.

\paragraph{PresenceHandler}
Presence stanzas inform an entity about the current status of a remote entity. Presence stanzas are broadcasted when the status changes. By registering a \texttt{PresenceHandler}-derived object with the Library, a program will receive such incoming presence stanzas for further processing. Registration happens by calling
\begin{flushleft}
\texttt{void registerPresenceHandler( PresenceHandler* ph );}
\end{flushleft}
Upon an incoming Presence stanza, \texttt{handlePresence()} is called, which has the following signature:
\begin{flushleft}
\texttt{virtual void handlePresence( iksid* from, iksubtype type, ikshowtype show, const char* msg ) \{\};}
\end{flushleft}
The processing object has immediate knowledge about sender (\texttt{iksid* from}), type (\texttt{iksubtype type}), display type (\texttt{ikshowtype show}) and content (\texttt{const char *msg}) of the incoming presence stanza.

\paragraph{SubscriptionHandler}
Subscription stanzas are a special case of Presence stanzas. However, their purpose is different from normal Presence, which is why they are handled separately. Subscription stanzas of different types are exchanged when client A wishes to add client B to its roster. By registering a \texttt{SubscriptionHandler}-derived object with the Library, a program will receive such incoming subscription stanzas for further processing. Registration happens by calling
\begin{flushleft}
\texttt{void registerSubscriptionHandler( SubscriptionHandler* mh );}
\end{flushleft}
Upon an incoming Subscription stanza, \texttt{handleSubscription()} is called, which has the following signature:
\begin{flushleft}
\texttt{virtual void handleSubscription( iksid* from, iksubtype type, const char *msg ) \{\};}
\end{flushleft}
The processing object has immediate knowledge about sender (\texttt{iksid* from}), type (\texttt{iksubtype type}) and content (\texttt{const char *msg}) of the incoming message.

\paragraph{Additional XMPP Abtraction Interfaces}
As mentioned above, the Library offers two additional interfaces which enable an application written against the XMPP Client Library to handle protocol extension in a abstracted way. On one hand side, the \texttt{Roster} class handles the contacts which are stored on the server-side contact list (the roster). It offers an extensive interface for roster management. The second interface is an abstraction of the Service Discovery extension. It is implemented in the \texttt{Disco} class.

\paragraph{}
Both of them use the \texttt{IqHandler} interface discussed above. They are written in a modular fashion and can serve as examples for further imlementations of protocol extensions.

\subsection{The Feeder Library}
\label{sec:feederlib}
\paragraph{}
The Feeder Library is separated from the Data Gatherer -- as shown in Figure \ref{fig:feeder} on Page \pageref{fig:feeder} -- to allow for re-use. The functionality the Feeder Library offers is completely independent from the format of the data that is sent over the wire and processed by the Worker. It makes direct use of the XMPP Client Library for the XMPP communication.

\paragraph{}
The purpose of the Feeder Library is, on one hand side, to accept data packets from the Feeder and forward them to a Worker. On the other hand side, it receives result packets from the Workers, evaluates them, stores statistical information about the processed packet in a database and finally passes the result packet to the Feeder.

\paragraph{}
Aditionally, the Feeder Library is responsible for keeping track of available Workers. When a Worker connects to the XMPP server, it announces its availability to all other entities that are listed in its roster -- to be exact, the XMPP server does so. Since the Feeder is on the roster of every Worker (this is a requirement), it gets notified about the newly available Worker. Using Service Discovery, the Feeder Library finds out whether a newly connected entity is capable of processing the data offered by the Data Gatherer, i.e. whether it is really a Worker and compatible. The addresses of all these Workers, together with their current status, are kept in a map. With every status change of a Worker this map is updated. A data packet arriving from the Feeder for distribution is sent to the first Worker available.

\paragraph{}
The inheritance diagram for the main class of the Feeder Library -- \texttt{Feeder} -- is shown in Figure \ref{fig:inhfeeder}.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.12}
\end{center}
\caption{Inheritance Diagram for Class \texttt{Feeder}}
\label{fig:inhfeeder}
\end{figure}

\texttt{Feeder} generally has to know about connection state changes so it inherits from \texttt{ConnectionListener}. Furthermore, to know about available Workers it implements the \texttt{RosterListener} interface. The Feeder determines via Service Discovery whether an entitiy listed on its roster is capable of processing data, which is why it implements the \texttt{DiscoHandler} interface. Last but not least, since data as well as result packets are wrapped into IQ stanzas, the \texttt{IqHandler} interface is necessary.

\paragraph{}
The communication between Data Gatherer and Feeder Library happens over a special interface following the following algorithm.

\begin{enumerate}
\item The Feeder Library starts by polling for data packets until the Data Gatherer has no more data available.
\item As soon as data is available again, the Data Gatherer starts pushing data packets until all the available Workers are busy processing data.
\item The Feeder Library starts polling -- see step 1.
\end{enumerate}

\paragraph{}
It also would have been possible to use either of the methods exclusively, but for reasons of efficiency in the communication between Data Gatherer and Feeder Library this approach was chosen. The justification is further discussed in Section \ref{sec:designjustification}.

\paragraph{}
The Data Gatherer has to implement the \texttt{PollHandler} interface and register the corresponding object by calling:
\begin{flushleft}
\texttt{void registerPollHandler( PollHandler* ph );}
\end{flushleft}
The actual poll happens by calling the \texttt{poll()} function:
\begin{flushleft}
\texttt{virtual char* poll() \{\};}
\end{flushleft}


\subsection{The Worker Library}
\label{sec:workerlib}
\paragraph{}
Like Data Gatherer and Feeder Library, Algorithm Implementation and Worker Library are separated for easy re-use (Figure \ref{fig:worker} on Page \pageref{fig:worker}). Again, the Worker Library's implementation is independent from type and format of data received from the Feeder and passed to the Algorithm Implementation. Also, the algorithm used to process the data does not influence the Worker Library.

\paragraph{}
The Worker Library offers an interface for the Algorithm Implementation to implement. An object derived from \texttt{DataHandler} has to be registered with the Library by calling:
\begin{flushleft}
\texttt{void registerDataHandler( DataHandler* dh );}
\end{flushleft}
A data packet is passed to the registered object by calling:
\begin{flushleft}
\texttt{virtual void data( const char* data ) \{\};}
\end{flushleft}

\paragraph{}
On startup, the Worker Library establishes a connection to the XMPP server and announces its availability to the Feeder. After that it just waits for a data packet to arrive. When such a packet is received, an acknowledgement is sent to prevent further packets from being sent to this node. The packet is then passed to the Algorithm Implementation for processing using the registered DataHandler. When the Algorithm finishes its processing it calls:
\begin{flushleft}
\texttt{void result( ResultCode code, const char* result );}
\end{flushleft}
\paragraph{}
The Worker Libary constructs a result packet and sends it off to the Feeder.

\paragraph{}
The inheritance diagram for the main class of the Worker Library -- \texttt{Worker} -- is shown in Figure \ref{fig:inhworker}.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.13}
\end{center}
\caption{Inheritance Diagram for Class \texttt{Worker}}
\label{fig:inhworker}
\end{figure}

\paragraph{}
\texttt{Worker} generally has to know about connection state changes so it inherits from \texttt{ConnectionListener}. Furthermore, to know about the presence of a Feeder and to subscribe to it, the \texttt{RosterListener} interface is implemented. Since data as well as result packets are wrapped into IQ stanzas, the \texttt{IqHandler} interface is necessary.


\subsection{Example Programs}
\label{sec:samples}
\paragraph{}
A set of sample programs has been implemented that demonstrates the usage of the previously discussed libraries. Sample Feeder and Worker together find prime factors of positive integers.

\paragraph{}
The Feeder is simply a counter which is incremented with every \texttt{poll()}.

\paragraph{}
The Worker contains the implementation of the Direct Search Factorization algorithm \cite{mathworld001,wikipedia007}. It tries to find prime factors by simply trying every possible (and reasonable) combination of primes.


\subsection{Statistics Viewer}
\paragraph{}
The Statistics Viewer is a web-based (written in PHP\footnote{PHP has its homepage at href{http://php.net}{http://php.net}}) means to access the statistical data produced by the Feeder in a convenient and user friendly way. In contrast to the previously discussed components, the Statistics Viewer has not been finished.


\subsection{Feeder Front End}
\paragraph{}
The Feeder Front End enables owners or operators of grids to access the Feeder and query it for its run-time parameters. Like the Statistics Viewer, the Feeder Front End has not been finished. It is supposed to use an extension to XMPP called Ad-hoc Commands which is defined in JEP-0050 \cite{jep0050}.

\paragraph{}
JEP-0050: Ad-hoc Commands offers users a way to execute commands on a remote entity. This does not mean the execution of arbitrary programs on the entity's machine, but usage of pre-defined commands within the entity. For example, a service could offer a command that restarts the service or shuts it down.

\paragraph{}
Similar to what the Worker Library does to announce its capability to process data, an entity offering ad-hoc commands and therefore implementing JEP-0050, announces this capability using Service Discovery (as described in Section \ref{sec:disco}).