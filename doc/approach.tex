\section{Technical Approach}

\subsection{Architecture}

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.0}
\end{center}
\caption{Project Architecture}
\label{fig:architecture}
\end{figure}

\paragraph{}
Figure \ref{fig:architecture} shows the project's architecture. On one hand side, a Feeder is responsible for creating or gathering data that has to be processed. This data is sent to one of the waiting Workers at a time via the XMPP server. The Workers, on the other hand side, do the necessary processing and return the result to the Feeder. This result is stored in a database. The Statistics Viewer can be used to view statistics about the returned results and the cluster operation.

\paragraph{}
Feeder and Worker are each split in two main components. This is shown in Figures \ref{fig:feeder} and \ref{fig:worker}, respectively.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.9}
\end{center}
\caption{The Feeder in Detail}
\label{fig:feeder}
\end{figure}

\paragraph{}
The Feeder Library communicates with the XMPP Server and the Worker on behalf of the Feeder Application. Likewise does the Worker Library take care of the XMPP communication for the Worker.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.10}
\end{center}
\caption{The Worker in Detail}
\label{fig:worker}
\end{figure}

\paragraph{}
Formerly, it was only mentioned briefly that both Worker and Feeder are likely to contain similar code which should be shared. Since the connectivity functionality is identical for both of the higher level components and is self-contained, it was decided to write a generic XMPP client library that can even be (and by the time of this writing is) used in other projects. Figure \ref{fig:justification} shows the collaboration of Feeder Library, Worker Library and XMPP Client Library.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.8}
\end{center}
\caption{Usage of the XMPP Client Library}
\label{fig:justification}
\end{figure}

\paragraph{}
Both higher level libraries base their entire network-based communication on the XMPP Client Library. Receiving and sending data is completely transparent. The XMPP Client Library could be replaced by another library implementing any other means of communication without hassle.

\subsection{Adressing of Workers}
\paragraph{}
The Feeder needs to be able to distinguish between different Workers in order to keep track of them and sending work data to a specific one. It does so by keeping a map of addresses of connected Workers and their respective current status.

\subsubsection{Node Addressing in XMPP}
\paragraph{}
In general, an address in XMPP (also known as Jabber ID or JID) is built using the following syntax:
\begin{center}
\texttt{[\{local\}@]\{server\}[/\{resource\}]}
\end{center}
An addressable node can be either of the following:
\begin{description}
\item[client] with an address of the form: \texttt{\{local\}@\{server\}/\{resource\}}
\item[component] with an address of the form: \texttt{\{local\}@\{server\}} 
\item[server] with  an address of the form: \texttt{\{server\}}
\end{description}
\paragraph{}
For the addressing, the resource part is optional under certain circumstances and an user is always reachable by addressing the bare (without resource part) Jabber ID. Even though an XMPP address looks a lot like an ordinary email address, the XMPP specification allows for more characters to be used in the local part, even whitespace is valid. The server part depends on domain naming rules valid in the Internet (at least if used there). This addressing scheme, including the range of valid characters in an XMPP address, is decribed in greater detail in RFC 3920: XMPP Core \cite{xmpp-core}.

\subsubsection{Addressing in This Project}
\label{sec:addressing}
\paragraph{}
The design of Worker and Feeder Libraries does not impose any limit whatsoever on the addresses of Workers besides those already defined in RFC 3920. This means it is even possible to have a Worker use the same Jabber ID like a users Instant Messaging account, except for the resource part. An example: User Joe has got an account on server \texttt{example.org}. Their client adds a resource of \texttt{JoesChatClient}. The resulting JID, under which Joe is reachable for chatting, would be:
\begin{center}
\texttt{joe@example.org/JoesChatClient}
\end{center}
If Joe chose to have a Worker use the same address, the full JID would look like:
\begin{center}
\texttt{joe@example.org/JoesWorker}
\end{center}
Following this scheme, it is possible to run a whole cluster using only a single account. Each Worker would simply add a different resource part to the bare address to form its unique JID.
\paragraph{}
Further advantages of using XMPP are discussed in Section \ref{sec:extensibility}.

\subsection{The XMPP Client Library}
\label{sec:clientlib}
\paragraph{}
The XMPP Client Library consists of one main class and several helper classes. The main class, \texttt{JClient}, is derived from the stream handling class \texttt{Stream}, which in turn is derived from the XML parser interface \texttt{Parser} and an XML tree abstraction, \texttt{Tree}. The inheritance diagram for \texttt{JClient} is shown in Figure \ref{fig:inhjclient}.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.11}
\end{center}
\caption{Inheritance Diagram for Class \texttt{JClient}}
\label{fig:inhjclient}
\end{figure}

\paragraph{}
The classes \texttt{Tree}, \texttt{Parser} and \texttt{Stream} were taken from the Iksemelmm\footnote{Originally written by Igor Goryachieff \texttt{<igor@jahber.org>}} library and modified slightly. They live in the \texttt{Iksemel} namespace and form an object-oriented wrapper interface to the Iksemel library. The build system creates a so-called convenience library from them which is then linked into the final XMPP Client Library.

\paragraph{}
The most simple example of using the XMPP Client Library would look like shown in Figure \ref{fig:usageExample}.

\begin{figure}[H]
\begin{listing}{1}
void Class::doIt()
{
  JClient* j = new JClient( "user", "resource",
                            "password", "resource" );
  j->connect();
}
\end{listing}
\caption{Simple XMPP Client Library Usage Example}
\label{fig:usageExample}
\end{figure}

\paragraph{}
In this fictious function \texttt{Class::doIt()} a new \texttt{JClient} object is created and initialised with the account's credentials necessary for connecting to an XMPP server (lines 3 and 4). As a consequence, the constructor of \texttt{JClient} as shown in Figure \ref{fig:JClientConstructor} is called.

\begin{figure}[H]
\begin{listing}{1}
JClient::JClient( const std::string username,
                  const std::string resource,
                  const std::string password,
                  const std::string server, int port )
  : m_username( username ), m_resource( resource ),
    m_password( password ), m_server( server ),
    m_port( port ), m_thread( 0 ),
    m_tls( true ), m_sasl( true ),
    m_autoPresence( true ), m_handleDiscoInfo( true ),
    m_handleDiscoItems( true ), m_idCount( 0 )
{
  init();
}
\end{listing}
\caption{Constructor of class JClient (simplified)}
\label{fig:JClientConstructor}
\end{figure}

\paragraph{}
Basically, a number of member variables are initialised. Most importantly, Transport Layer Security\footnote{Encryption of the communication channel.} (TLS) \cite{rfc2246} and Simple Authentication and Security Layer\footnote{Secure Authentication even without encrypted communication channel.} (SASL) \cite{rfc2222} are enabled (line 8). Additionally, but not shown in Figure \ref{fig:JClientConstructor}, some more XMPP features which the library supports, are enabled by the \texttt{init()} function. This includes Service Discovery\footnote{JEP-0030: Service Discovery defines methods to discover capabilities of other nodes in an XMPP network.} \cite{jep0030}.

\paragraph{}
The function \texttt{connect()}, called in line 5 in Figure \ref{fig:usageExample}, establishes the connection to the XMPP server and creates a new thread that receives incoming TCP/IP packets and hands them to the XML parser of Iksemel.

\paragraph{}
The following interaction with the XMPP server is completely event driven. This is why the example in Figure \ref{fig:usageExample} is not very useful as it is: An application using the Library like this will never now that anything happend to the XMPP connection. The solution is to use the event notification interfaces the Library offers.

\subsection{Event Notification Interfaces}
\label{sec:interfaces}
\paragraph{}
The client library offers a simple yet powerful public interface that enables programs to receive events from an XMPP server with approximately less than 10 additional lines of code. The supported events are:
\begin{itemize}
\item Established and canceled (also lost) connection
\item Incoming messages
\item Incoming IQ stanzas
\item Incoming presence stanzas
\item Incoming subscription stanzas
\end{itemize}
\paragraph{}
Additionally, for IQ events a namespace filter can be utilised. With it, all the possible stanza types that XMPP Core supports are covered.

\paragraph{}
The event notification scheme used by the Client Library follows the so-called Observer Pattern \cite{wikipedia003}. An object interested in XMPP events needs to indicate this to the client library by registering with it as an appropriate event handler. When a stanza arrives from the server, the library calls a special function in every registered object. Figure \ref{fig:observer1} shows an example sequence of registering with the Client Library and being called back by it later on.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.7}
\end{center}
\caption{Sequence Diagram Illustrating the Observer Pattern}
\label{fig:observer1}
\end{figure}
\paragraph{}
The following interfaces are available for use by an object. Each interface is defined in their own header file for inclusion by interested classes. The virtual function definded therein and listed here have to be reimplemented by the listener objects in order to actually receive the occuring events they listen for.

\paragraph{ConnectionListener}
To be notified about connection-related events, an object must be derived from \texttt{ConnectionListener}. It has to be added to the listener queue by calling
\begin{flushleft}
\texttt{JClient::registerConnectionListener( ConnectionListener* cl );}
\end{flushleft}
After establishing an connection to the XMPP server and successfully authenticating with it, the function
\begin{flushleft}
\texttt{virtual void onConnect() \{\};}
\end{flushleft}
is called in any registered object. Likewise, as soon as a disconnect is detected, either due to a closed stream or a lost TCP/IP connection, 
\begin{flushleft}
\texttt{virtual void onDisconnect() \{\};}
\end{flushleft}
is called.

\paragraph{MessageHandler}
In XMPP, Messages contain the text of a conversation between client users, usually humans. By registering a \texttt{MessageHandler}-derived object with the Library, a program will receive such incoming messages for further processing. Registration happens by calling
\begin{flushleft}
\texttt{void registerMessageHandler( MessageHandler* mh );}
\end{flushleft}
Upon an incoming Message stanza, \texttt{handleMessage()} is called, which has the following signature:
\begin{flushleft}
\texttt{virtual void handleMessage( iksid* from, iksubtype type, const char *msg ) \{\};}
\end{flushleft}
The processing object has immediate knowledge of sender (\texttt{iksid* from}), type (\texttt{iksubtype type}) and content (\texttt{const char *msg}) of the incoming message.

\paragraph{IqHandler}
IQ stanzas usually contain control commands that are evaluated by the client software of a node and not shown to the user. By registering an \texttt{IqHandler}-derived object with the Library, a program will receive such incoming IQ stanzas for further processing. Registration happens by calling
\begin{flushleft}
\texttt{void registerIqHandler( IqHandler* ih, std::string xmlns );}
\end{flushleft}
Upon an incoming IQ stanza, \texttt{handleIq()} is called, which has the following signature:
\begin{flushleft}
\texttt{virtual void handleIq( const char* xmlns, ikspak* pak ) \{\};}
\end{flushleft}
The processing object has immediate knowledge of the XML namespace (\texttt{const char* xmlns}) and, additionally, access to the complete packet's content by accessing \texttt{ikspak* pak}.

\paragraph{PresenceHandler}
Presence stanzas inform a node about the current status of a remote node. Presence stanzas are broadcasted when the status changes. By registering a \texttt{PresenceHandler}-derived object with the Library, a program will receive such incoming presence stanzas for further processing. Registration happens by calling
\begin{flushleft}
\texttt{void registerPresenceHandler( PresenceHandler* ph );}
\end{flushleft}
Upon an incoming Presence stanza, \texttt{handlePresence()} is called, which has the following signature:
\begin{flushleft}
\texttt{virtual void handlePresence( iksid* from, iksubtype type, ikshowtype show, const char* msg ) \{\};}
\end{flushleft}
The processing object has immediate knowledge about sender (\texttt{iksid* from}), type (\texttt{iksubtype type}), display type (\texttt{ikshowtype show}) and content (\texttt{const char *msg}) of the incoming presence stanza.

\paragraph{SubscriptionHandler}
Subscription stanzas are a special case of Presence stanzas. However, their prupose is different from normal Presence, which is why they are handled separately. Subscription stanzas of different types are exchanged when client A wishes to add client B to its roster. By registering a \texttt{SubscriptionHandler}-derived object with the Library, a program will receive such incoming subscription stanzas for further processing. Registration happens by calling
\begin{flushleft}
\texttt{void registerSubscriptionHandler( SubscriptionHandler* mh );}
\end{flushleft}
Upon an incoming Subscription stanza, \texttt{handleSubscription()} is called, which has the following signature:
\begin{flushleft}
\texttt{virtual void handleSubscription( iksid* from, iksubtype type, const char *msg ) \{\};}
\end{flushleft}
The processing object has immediate knowledge about sender (\texttt{iksid* from}), type (\texttt{iksubtype type}) and content (\texttt{const char *msg}) of the incoming message.


\subsection{The Feeder Library}
\label{sec:feederlib}
\paragraph{}
The Feeder Library is separated from the Feeder -- like shown in Figure \ref{fig:feeder} -- to allow for re-use. The functionality the Feeder Library offers is completely independent from the format of the data that is sent over the wire and processed by the Worker. It makes direct use of the XMPP Client Library for the XMPP communication.

\paragraph{}
The purpose of the Feeder Library is, on one hand side, to accept data packets from the Feeder and forward them to a Worker. On the other hand side, it receives result packets from the Workers, evaluates them, stores statistical information about the processed packet in a database and finally passes the result packet to the Feeder.

\paragraph{}
Aditionally, the Feeder Library is responsible for keeping track of available Workers. When a Worker connects to the XMPP server, it announces its availability to all other nodes that are listed in its roster -- to be exact, the XMPP server does so. Since the Feeder is on the roster of every Worker (this is a requirement), it gets notified about the newly available Worker. The addresses of all these Workers, together with their current status, are kept in a map. With every status change of a Worker this map is updated. A data packet arriving from the Feeder for distribution is sent to the first Worker available.

\paragraph{}
The inheritance diagram for the main class of the Feeder Library -- \texttt{Feeder} -- is shown in Figure \ref{fig:inhfeeder}.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.12}
\end{center}
\caption{Inheritance Diagram for Class \texttt{Feeder}}
\label{fig:inhfeeder}
\end{figure}

\texttt{Feeder} generally has to know about connection state changes so it inherits from \texttt{ConnectionListener}. Furthermore, to be able to authorise subscription requests from Workers it implements the \texttt{SubscriptionHandler} interface. Since data as well as result packets are wrapped into IQ stanzas, the \texttt{IqHandler} interface is necessary. Last but not least, \texttt{PresenceHandler} informs about state changes of the Workers.

\paragraph{}
The communication between Feeder and Feeder Library happens over a special interface following the following algorithm.

\begin{enumerate}
\item The Feeder Library starts by polling for data packets until the Feeder has no more data vailable.
\item The Feeder starts pushing new data packets until all the available Workers are busy processing data.
\item The Feeder Library starts polling -- see step 1.
\end{enumerate}

\paragraph{}
It also would have been possible to use either of the methods exclusively, but for reasons of efficiency in the communication between Feeder and Feeder Library this approach was chosen. The justification is further discussed in Section \ref{sec:discussion}.

\paragraph{}
The Feeder has to implement the \texttt{PollHandler} interface and register the corresponding object by calling:
\begin{flushleft}
\texttt{void registerPollHandler( PollHandler* ph );}
\end{flushleft}
The actual poll happens by calling the \texttt{poll()} function:
\begin{flushleft}
\texttt{virtual char* poll() \{\};}
\end{flushleft}


\subsection{The Worker Library}
\label{sec:workerlib}
\paragraph{}
Like Feeder and Feeder Library, Worker and Worker Library are separated for easy re-use (Figure \ref{fig:worker}). Again, the Worker Library's implementation is independent from type and format of data received from the Feeder and passed to the Worker. Also, the algorithm used to process the data does not influence the Worker Library.

\paragraph{}
The Worker Library offers an interface for the Worker to implement. An object derived from \texttt{DataHandler} has to be registered with the Library by calling:
\begin{flushleft}
\texttt{void registerDataHandler( DataHandler* dh );}
\end{flushleft}
A data packet is passed to the registered object by calling:
\begin{flushleft}
\texttt{virtual void data( const char* data ) \{\};}
\end{flushleft}

\paragraph{}
On startup, the Worker Library establishes a connection to the XMPP server and announces its availability to the Feeder. After that it just waits for a data packet to arrive. When such a packet is received, the XMPP status is immediately changed to \texttt{unavailable} to prevent further packets from being sent to this node. The packet is then passed to the Worker for processing using the registered DataHandler. When the Worker finishes its processing it calls:
\begin{flushleft}
\texttt{void result( ResultCode code, const char* result );}
\end{flushleft}
The Worker Libary constructs a result packet and sends it off to the Feeder. After that, the status is changed back to \texttt{available} to let the Feeder update its map of Workers.

\paragraph{}
The inheritance diagram for the main class of the Worker Library -- \texttt{Worker} -- is shown in Figure \ref{fig:inhworker}.

\begin{figure}[H]
\begin{center}
\includegraphics{fyp.13}
\end{center}
\caption{Inheritance Diagram for Class \texttt{Worker}}
\label{fig:inhworker}
\end{figure}

\paragraph{}
\texttt{Worker} generally has to know about connection state changes so it inherits from \texttt{ConnectionListener}. Furthermore, to be able to receive answers to its subscription requests it implements the \texttt{SubscriptionHandler} interface. Since data as well as result packets are wrapped into IQ stanzas, the \texttt{IqHandler} interface is necessary.


\subsection{Example Programs}
\paragraph{}

\subsection{Statistics Viewer}
\paragraph{}

\subsection{Feeder Frontend}
\paragraph{}
