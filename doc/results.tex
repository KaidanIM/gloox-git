\section{Results and Discussion}
\label{sec:discussion}

\subsection{Testing}
\label{sec:testing}
\paragraph{}
The development strategy used during this project is roughly related to evolutionary prototyping. A small prototype is extended with more and more ideas until the whole thing does what it's expected to do. Every stage is tested individually for correct implementation and conformance to used standards such as XMPP. Testing small changes, and fixing them as necessary, is easier than testing after huge changes. This is the reason why there is no dedicated testing period declared in the time planning.


\subsection{Extensibility}
\label{sec:extensibility}

\subsubsection{Load Balancing}
\paragraph{}
As discussed in Section \ref{sec:addressing} and \ref{sec:feederlib}, the Feeder Library stores the full JID for distinction between Workers. A very interesting outcome of this restriction-less design is the possibility to add more than one XMPP server to the grid and thereby effectively create a load-balanced XMPP server cluster. The limit then becomes the memory of the machine running the Feeder -- it caches data and stores the addresses of all the Workers. But even the Feeder is -- sort of -- distributable. It is possible to have more than one Feeder running in an XMPP network.

\subsubsection{Dynamic Grid}
\paragraph{}
The design of XMPP and the Feeder Libraries allows for addition and removal, respectively, of nodes at run-time. This means that the size of the cluster is fully dynamic. Use cases include:
\begin{itemize}
\item A grid distributed over the Internet. Similar to Seti@Home, users can connect to the cluster and contribute their machine's processor time at their will.
\item In a university, school or company, machines could be added to a grid when they are idle. As soon as a machine is needed for a different task, it is temporarily removed from the cluster. This could happen automated and without user intervention if the Worker process ran in the background all the time and monitored the CPU utilisation of the machine.
\end{itemize}

\subsubsection{Physical Node Location}
\paragraph{}
The distributability of XMPP servers and nodes as well as the use case from the previous section implies that there is no restriction on the physical distance between nodes and servers. Of course, greater distances add to the delay of transmissions. But the processing time of data packets is considered high enough to make this effect neglectable.

\subsection{Design Justification: Poll vs. Push}
\label{sec:designjustification}
\paragraph{}
The combination of polling and pushing was chosen to reduce the Feeder's impact on the performance of the whole system and to improve the grid's efficiency. Both constant polling and pushing might, on one hand side, influence the machine's performance negatively if the interval chosen is too low. On the other hand side, if the interval is too high, valuable processing time might get lost because Workers don't get new data to work on as soon as it is available, but only on interval boundaries. The same applies for Workers being available again. They also only get new data packets on interval boundaries instead of directly after their availability.

\subsection{Disadvantages of XMPP}
\paragraph{}
The system proposed in this project can unfold its full power with data that takes a relatively long time to deal with, such as \textit{"protein folding, financial modelling, earthquake simulation, climate/weather modelling etc"} \cite{wikipedia005}. The reasons are:
\begin{itemize}
\item XML adds an overhead to the wire communication that should not be neglected. The IQ stanza sent to the Workers containing the data is 117 bytes in size, excluding payload, source and destination address. This is, per se, a huge frame and additionally might be much more than the actual payload.
\item The system has two bottlenecks, the Feeder and the XMPP server, respectively.
\end{itemize}

\paragraph{}
The bottom line is, the implemented system is not very performant when used with data which only takes a short time to process. For example, prime factorisation as implemented in the sample programs is very fast for small numbers. The overhead of XMPP is clearly visible here. However, no actual performance tests have been conducted in the context of this project as the system is not intended for such a use case in reality and aside from the provided examples.

\subsection{Standards Compliance}
\paragraph{}
The software written during this project does not completely comply to the XMPP standard as written down in RFC 3920 and RFC 3921 because not all aspects of these standards were implemented. To the author's best knowledge, those parts that were implemented do comply to the respective RFC or JEP.
